/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*                                                      */
/* File:  ventilador.c                                  */
/*                                                      */
/* Author: Automatically generated by Xfuzzy            */
/*                                                      */
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

#include <stdio.h>
#include <math.h>
#include "ventilador.h"

/*======================================================*/
/*  Common function to compute a fuzzy number           */
/*======================================================*/

static double compute(FuzzyNumber fn,double x) {
 int length = fn.length;
 int i;
 double imp = fn.imp(fn.degree[0],fn.conc[0].equal(x));
 double mu = imp;

 for(i=1; i<length; i++) {
  imp = fn.imp(fn.degree[i],fn.conc[i].equal(x));
  mu = fn.also(mu,imp);
 }
 return mu;
}

/*======================================================*/
/*  MembershipFunction MF_xfl_trapezoid                 */
/*======================================================*/

/*------------------------------------------------------*/
/* Function to compute an equal relationship            */
/*------------------------------------------------------*/

static double MF_xfl_trapezoid_equal(double x, double min, double max, double step, double a, double b, double c, double d) {
    return (x<a || x>d? 0: (x<b? (x-a)/(b-a) : (x<c?1 : (d-x)/(d-c)))); 

}

/*======================================================*/
/*  Operatorset OP_Default                              */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the operator ALSO                     */
/*------------------------------------------------------*/

static double OP_Default_Also(double a, double b) {
    return (a>b? a : b); 

}

/*------------------------------------------------------*/
/* Description of the operator IMPLICATION              */
/*------------------------------------------------------*/

static double OP_Default_Imp(double a, double b) {
    return (a<b? a : b); 

}

/*------------------------------------------------------*/
/* Description of the defuzzification method            */
/*------------------------------------------------------*/

static double OP_default_Defuz(FuzzyNumber mf) {
 double min = mf.min;
 double max = mf.max;
 double step = mf.step;
     double x, m, num=0, denom=0;
     for(x=min; x<=max; x+=step) {
      m = compute(mf,x);
      num += x*m;
      denom += m;
     }
     if(denom==0) return (min+max)/2;
     return num/denom;

}


/*======================================================*/
/*  Type TP_tTemp                                       */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label frio                        */
/*------------------------------------------------------*/

static double TP_tTemp_frio_equal(double x){
   return MF_xfl_trapezoid_equal(x,0.0,55.0,0.21568627450980393,-11.0,0.0,15.0,28.0);
}

/*------------------------------------------------------*/
/* Description of the label caliente                    */
/*------------------------------------------------------*/

static double TP_tTemp_caliente_equal(double x){
   return MF_xfl_trapezoid_equal(x,0.0,55.0,0.21568627450980393,22.0,35.0,55.0,66.0);
}

/*======================================================*/
/*  Type TP_tVelocidad                                  */
/*======================================================*/

/*------------------------------------------------------*/
/* Description of the label lenta                       */
/*------------------------------------------------------*/

static double TP_tVelocidad_lenta_equal(double x){
   return MF_xfl_trapezoid_equal(x,0.0,100.0,0.39215686274509803,-20.0,0.0,40.0,60.0);
}

/*------------------------------------------------------*/
/* Description of the label rapida                      */
/*------------------------------------------------------*/

static double TP_tVelocidad_rapida_equal(double x){
   return MF_xfl_trapezoid_equal(x,0.0,100.0,0.39215686274509803,40.0,60.0,100.0,120.0);
}

/*======================================================*/
/*  Rulebase RL_ventilador                              */
/*======================================================*/

static void RL_ventilador(double temp, double *vel) {
 double _rl;

 double _vel_degree[2];
 Consequent _vel_conc[2];
 FuzzyNumber _vel;
 _vel.min = 0.0;
 _vel.max = 100.0;
 _vel.step = 0.39215686274509803;
 _vel.imp = OP_Default_Imp;
 _vel.also = OP_Default_Also;
 _vel.length = 2;
 _vel.degree = _vel_degree;
 _vel.conc = _vel_conc;
 int _vel_i = 0;

 double _temp_eq[2];
 _temp_eq[0] = TP_tTemp_frio_equal(temp);
 _temp_eq[1] = TP_tTemp_caliente_equal(temp);

 _rl = _temp_eq[0];
 _vel_degree[_vel_i] = _rl;
 _vel_conc[_vel_i].equal = TP_tVelocidad_lenta_equal;
 _vel_i++;

 _rl = _temp_eq[1];
 _vel_degree[_vel_i] = _rl;
 _vel_conc[_vel_i].equal = TP_tVelocidad_rapida_equal;
 _vel_i++;

 *vel = OP_default_Defuz(_vel);
}


/*======================================================*/
/*                   Inference Engine                   */
/*======================================================*/

void ventiladorInferenceEngine(double Temp, double *_d_Vel) {
 double Vel;
 RL_ventilador(Temp, &Vel);
 *_d_Vel = Vel;
}

